
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/pretrained_models.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials_pretrained_models.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_pretrained_models.py:


Using pretrained models
=======================
This tutorial explains how to use pretrained models in TorchRL.

.. GENERATED FROM PYTHON SOURCE LINES 8-16

At the end of this tutorial, you will be capable of using pretrained models
for efficient image representation, and fine-tune them.

TorchRL provides pretrained models that are to be used either as transforms or as
components of the policy. As the sematic is the same, they can be used interchangeably
in one or the other context. In this tutorial, we will be using R3M (https://arxiv.org/abs/2203.12601),
but other models (e.g. VIP) will work equally well.


.. GENERATED FROM PYTHON SOURCE LINES 16-25

.. code-block:: default

    import torch.cuda
    from tensordict.nn import TensorDictSequential
    from torch import nn
    from torchrl.envs import R3MTransform, TransformedEnv
    from torchrl.envs.libs.gym import GymEnv
    from torchrl.modules import Actor

    device = "cuda:0" if torch.cuda.device_count() else "cpu"








.. GENERATED FROM PYTHON SOURCE LINES 26-30

Let us first create an environment. For the sake of simplicity, we will be using
a common gym environment. In practice, this will work in more challenging, embodied
AI contexts (e.g. have a look at our Habitat wrappers).


.. GENERATED FROM PYTHON SOURCE LINES 30-32

.. code-block:: default

    base_env = GymEnv("Ant-v4", from_pixels=True, device=device)








.. GENERATED FROM PYTHON SOURCE LINES 33-40

Let us fetch our pretrained model. We ask for the pretrained version of the model through the
download=True flag. By default this is turned off.
Next, we will append our transform to the environment. In practice, what will happen is that
each batch of data collected will go through the transform and be mapped on a "r3m_vec" entry
in the output tensordict. Our policy, consisting of a single layer MLP, will then read this vector and compute
the corresponding action.


.. GENERATED FROM PYTHON SOURCE LINES 40-53

.. code-block:: default

    r3m = R3MTransform(
        "resnet50",
        in_keys=["pixels"],
        download=True,
    )
    env_transformed = TransformedEnv(base_env, r3m)
    net = nn.Sequential(
        nn.LazyLinear(128, device=device),
        nn.Tanh(),
        nn.Linear(128, base_env.action_spec.shape[-1], device=device),
    )
    policy = Actor(net, in_keys=["r3m_vec"])





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Downloading: "https://pytorch.s3.amazonaws.com/models/rl/r3m/r3m_50.pt" to /github/home/.cache/torch/hub/checkpoints/r3m_50.pt
      0%|          | 0.00/374M [00:00<?, ?B/s]      4%|4         | 16.4M/374M [00:00<00:03, 119MB/s]      8%|8         | 31.7M/374M [00:00<00:03, 116MB/s]     11%|#1        | 42.8M/374M [00:00<00:03, 111MB/s]     15%|#4        | 55.6M/374M [00:00<00:02, 119MB/s]     18%|#7        | 67.0M/374M [00:00<00:03, 100MB/s]     22%|##1       | 81.0M/374M [00:00<00:02, 113MB/s]     25%|##4       | 92.3M/374M [00:00<00:02, 109MB/s]     28%|##7       | 103M/374M [00:00<00:02, 106MB/s]      30%|###       | 113M/374M [00:01<00:02, 104MB/s]     33%|###2      | 123M/374M [00:01<00:02, 100MB/s]     36%|###5      | 133M/374M [00:01<00:02, 96.7MB/s]     39%|###8      | 145M/374M [00:01<00:02, 104MB/s]      41%|####1     | 155M/374M [00:01<00:02, 96.3MB/s]     44%|####3     | 164M/374M [00:01<00:02, 91.3MB/s]     48%|####7     | 178M/374M [00:01<00:01, 107MB/s]      50%|#####     | 189M/374M [00:01<00:01, 105MB/s]     53%|#####3    | 199M/374M [00:02<00:01, 100MB/s]     56%|#####6    | 210M/374M [00:02<00:01, 103MB/s]     59%|#####8    | 220M/374M [00:02<00:01, 89.4MB/s]     61%|######1   | 229M/374M [00:02<00:01, 92.6MB/s]     65%|######5   | 244M/374M [00:02<00:01, 108MB/s]      68%|######7   | 254M/374M [00:02<00:01, 103MB/s]     71%|#######   | 264M/374M [00:02<00:01, 86.2MB/s]     74%|#######4  | 279M/374M [00:02<00:01, 85.9MB/s]     78%|#######8  | 293M/374M [00:03<00:00, 93.7MB/s]     81%|########1 | 304M/374M [00:03<00:00, 97.8MB/s]     85%|########4 | 318M/374M [00:03<00:00, 110MB/s]      88%|########7 | 329M/374M [00:03<00:00, 109MB/s]     91%|######### | 340M/374M [00:03<00:00, 112MB/s]     94%|#########3| 351M/374M [00:03<00:00, 94.7MB/s]     96%|#########6| 361M/374M [00:03<00:00, 95.6MB/s]    100%|##########| 374M/374M [00:03<00:00, 102MB/s] 




.. GENERATED FROM PYTHON SOURCE LINES 54-56

Let's check the number of parameters of the policy:


.. GENERATED FROM PYTHON SOURCE LINES 56-58

.. code-block:: default

    print("number of params:", len(list(policy.parameters())))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    number of params: 4




.. GENERATED FROM PYTHON SOURCE LINES 59-61

We collect a rollout of 32 steps and print its output:


.. GENERATED FROM PYTHON SOURCE LINES 61-64

.. code-block:: default

    rollout = env_transformed.rollout(32, policy)
    print("rollout with transform:", rollout)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    rollout with transform: TensorDict(
        fields={
            action: Tensor(shape=torch.Size([32, 8]), device=cpu, dtype=torch.float32, is_shared=False),
            done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            next: TensorDict(
                fields={
                    done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
                    r3m_vec: Tensor(shape=torch.Size([32, 2048]), device=cpu, dtype=torch.float32, is_shared=False),
                    reward: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.float32, is_shared=False)},
                batch_size=torch.Size([32]),
                device=cpu,
                is_shared=False),
            r3m_vec: Tensor(shape=torch.Size([32, 2048]), device=cpu, dtype=torch.float32, is_shared=False),
            reward: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.float32, is_shared=False)},
        batch_size=torch.Size([32]),
        device=cpu,
        is_shared=False)




.. GENERATED FROM PYTHON SOURCE LINES 65-69

For fine tuning, we integrate the transform in the policy after making the parameters
trainable. In practice, it may be wiser to restrict this to a subset of the parameters (say the last layer
of the MLP).


.. GENERATED FROM PYTHON SOURCE LINES 69-73

.. code-block:: default

    r3m.train()
    policy = TensorDictSequential(r3m, policy)
    print("number of params after r3m is integrated:", len(list(policy.parameters())))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    number of params after r3m is integrated: 163




.. GENERATED FROM PYTHON SOURCE LINES 74-78

Again, we collect a rollout with R3M. The structure of the output has changed slightly, as now
the environment returns pixels (and not an embedding). The embedding "r3m_vec" is an intermediate
result of our policy.


.. GENERATED FROM PYTHON SOURCE LINES 78-81

.. code-block:: default

    rollout = base_env.rollout(32, policy)
    print("rollout, fine tuning:", rollout)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    rollout, fine tuning: TensorDict(
        fields={
            action: Tensor(shape=torch.Size([32, 8]), device=cpu, dtype=torch.float32, is_shared=False),
            done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            next: TensorDict(
                fields={
                    done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
                    pixels: Tensor(shape=torch.Size([32, 480, 480, 3]), device=cpu, dtype=torch.uint8, is_shared=False),
                    reward: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.float32, is_shared=False)},
                batch_size=torch.Size([32]),
                device=cpu,
                is_shared=False),
            r3m_vec: Tensor(shape=torch.Size([32, 2048]), device=cpu, dtype=torch.float32, is_shared=False),
            reward: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.float32, is_shared=False)},
        batch_size=torch.Size([32]),
        device=cpu,
        is_shared=False)




.. GENERATED FROM PYTHON SOURCE LINES 82-89

The easiness with which we have swapped the transform from the env to the policy
is due to the fact that both behave like TensorDictModule: they have a set of `"in_keys"` and
`"out_keys"` that make it easy to read and write output in different context.

To conclude this tutorial, let's have a look at how we could use R3M to read
images stored in a replay buffer (e.g. in an offline RL context). First, let's build our dataset:


.. GENERATED FROM PYTHON SOURCE LINES 89-94

.. code-block:: default

    from torchrl.data import LazyMemmapStorage, ReplayBuffer

    storage = LazyMemmapStorage(1000, device=device)
    rb = ReplayBuffer(storage=storage, transform=r3m)








.. GENERATED FROM PYTHON SOURCE LINES 95-98

We can now collect the data (random rollouts for our purpose) and fill the replay
buffer with it:


.. GENERATED FROM PYTHON SOURCE LINES 98-104

.. code-block:: default

    total = 0
    while total < 1000:
        tensordict = base_env.rollout(1000)
        rb.extend(tensordict)
        total += tensordict.numel()








.. GENERATED FROM PYTHON SOURCE LINES 105-107

Let's check what our replay buffer storage looks like. It should not contain the "r3m_vec" entry
since we haven't used it yet:

.. GENERATED FROM PYTHON SOURCE LINES 107-109

.. code-block:: default

    print("stored data:", storage._storage)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    stored data: TensorDict(
        fields={
            action: MemmapTensor(shape=torch.Size([1000, 8]), device=cpu, dtype=torch.float32, is_shared=False),
            done: MemmapTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            next: TensorDict(
                fields={
                    done: MemmapTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.bool, is_shared=False),
                    pixels: MemmapTensor(shape=torch.Size([1000, 480, 480, 3]), device=cpu, dtype=torch.uint8, is_shared=False),
                    reward: MemmapTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.float32, is_shared=False)},
                batch_size=torch.Size([1000]),
                device=cpu,
                is_shared=False),
            pixels: MemmapTensor(shape=torch.Size([1000, 480, 480, 3]), device=cpu, dtype=torch.uint8, is_shared=False),
            reward: MemmapTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.float32, is_shared=False)},
        batch_size=torch.Size([1000]),
        device=cpu,
        is_shared=False)




.. GENERATED FROM PYTHON SOURCE LINES 110-113

When sampling, the data will go through the R3M transform, giving us the processed data that we wanted.
In this way, we can train an algorithm offline on a dataset made of images:


.. GENERATED FROM PYTHON SOURCE LINES 113-116

.. code-block:: default

    batch = rb.sample(32)
    print("data after sampling:", batch)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    data after sampling: TensorDict(
        fields={
            action: Tensor(shape=torch.Size([32, 8]), device=cpu, dtype=torch.float32, is_shared=False),
            done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            next: TensorDict(
                fields={
                    done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
                    pixels: Tensor(shape=torch.Size([32, 480, 480, 3]), device=cpu, dtype=torch.uint8, is_shared=False),
                    reward: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.float32, is_shared=False)},
                batch_size=torch.Size([32]),
                device=cpu,
                is_shared=False),
            r3m_vec: Tensor(shape=torch.Size([32, 2048]), device=cpu, dtype=torch.float32, is_shared=False),
            reward: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.float32, is_shared=False)},
        batch_size=torch.Size([32]),
        device=cpu,
        is_shared=False)





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  23.699 seconds)

**Estimated memory usage:**  4890 MB


.. _sphx_glr_download_tutorials_pretrained_models.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: pretrained_models.py <pretrained_models.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: pretrained_models.ipynb <pretrained_models.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
